"""
Exploit API routes.

Provides REST API endpoints for accessing exploit data with support
for multiple output formats (JSON, JSON-LD, HTML+RDFa).
"""

import asyncio
import json
from typing import Optional, List
from fastapi import APIRouter, Depends, Query, HTTPException, Request, Response
from fastapi.responses import HTMLResponse, JSONResponse
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func, or_

from ..models.database import get_db
from ..models.exploit import (
    Exploit, ExploitResponse, ExploitListResponse,
    SoftwareType, ExploitType, SeverityLevel, PlatformType
)
from ..services.sparql_service import get_sparql_service
from ..services.cache_proxy import get_cache_proxy
from ..services.exploitdb_git_loader import force_load_exploits
from ..config import get_settings
from .serializers import (
    exploit_to_jsonld,
    exploit_to_rdfa_html,
    exploits_list_to_jsonld,
)

router = APIRouter(prefix="/api/exploits", tags=["exploits"])
settings = get_settings()


@router.get("", response_model=ExploitListResponse)
async def list_exploits(
    request: Request,
    page: int = Query(1, ge=1),
    page_size: int = Query(20, ge=1, le=100),
    platform: Optional[str] = None,
    software_type: Optional[str] = None,
    exploit_type: Optional[str] = None,
    severity: Optional[str] = None,
    search: Optional[str] = None,
    format: str = Query("json", regex="^(json|jsonld|html)$"),
    db: AsyncSession = Depends(get_db),
):
    """
    List exploits with filtering and pagination.
    
    Supports multiple output formats:
    - json: Standard JSON response
    - jsonld: JSON-LD with schema.org vocabulary
    - html: HTML page with RDFa semantic markup
    """
    cache = get_cache_proxy()
    cache_key = f"exploits:list:{page}:{page_size}:{platform}:{software_type}:{exploit_type}:{severity}:{search}"
    
    # Try cache for JSON format
    if format == "json":
        cached = await cache.get(cache_key)
        if cached:
            return cached
    
    # Build query
    query = select(Exploit)
    count_query = select(func.count(Exploit.id))
    
    # Apply filters
    if platform:
        query = query.where(Exploit.platform == platform)
        count_query = count_query.where(Exploit.platform == platform)
    
    if software_type:
        query = query.where(Exploit.software_type == software_type)
        count_query = count_query.where(Exploit.software_type == software_type)
    
    if exploit_type:
        query = query.where(Exploit.exploit_type == exploit_type)
        count_query = count_query.where(Exploit.exploit_type == exploit_type)
    
    if severity:
        query = query.where(Exploit.severity == severity)
        count_query = count_query.where(Exploit.severity == severity)
    
    if search:
        search_filter = or_(
            Exploit.title.ilike(f"%{search}%"),
            Exploit.description.ilike(f"%{search}%"),
            Exploit.software_name.ilike(f"%{search}%"),
        )
        query = query.where(search_filter)
        count_query = count_query.where(search_filter)
    
    # Get total count
    total_result = await db.execute(count_query)
    total = total_result.scalar() or 0
    
    # Apply pagination
    offset = (page - 1) * page_size
    query = query.order_by(Exploit.created_at.desc()).offset(offset).limit(page_size)
    
    # Execute query
    result = await db.execute(query)
    exploits = result.scalars().all()
    
    has_next = offset + len(exploits) < total
    
    # Format response based on requested format
    if format == "jsonld":
        jsonld = exploits_list_to_jsonld(exploits, page, page_size, total)
        return JSONResponse(
            content=jsonld,
            media_type="application/ld+json",
        )
    
    if format == "html":
        html = generate_exploits_list_html(exploits, page, page_size, total, request)
        return HTMLResponse(content=html)
    
    # Default JSON response
    response = ExploitListResponse(
        items=[ExploitResponse.model_validate(e) for e in exploits],
        total=total,
        page=page,
        page_size=page_size,
        has_next=has_next,
    )
    
    # Cache the response
    await cache.set(cache_key, response, ttl=60)
    
    return response


@router.get("/{exploit_id}")
async def get_exploit(
    exploit_id: int,
    request: Request,
    format: str = Query("json", regex="^(json|jsonld|html|turtle|rdf)$"),
    db: AsyncSession = Depends(get_db),
):
    """
    Get a single exploit by ID.
    
    Supports multiple output formats:
    - json: Standard JSON
    - jsonld: JSON-LD with schema.org
    - html: HTML with RDFa
    - turtle: RDF Turtle format
    - rdf: RDF/XML format
    """
    cache = get_cache_proxy()
    cache_key = f"exploit:{exploit_id}:{format}"
    
    # Try cache
    cached = await cache.get(cache_key)
    if cached:
        if format == "json":
            return cached
        elif format == "jsonld":
            return JSONResponse(content=cached, media_type="application/ld+json")
        elif format == "html":
            return HTMLResponse(content=cached)
        elif format == "turtle":
            return Response(content=cached, media_type="text/turtle")
        elif format == "rdf":
            return Response(content=cached, media_type="application/rdf+xml")
    
    # Fetch from database
    result = await db.execute(select(Exploit).where(Exploit.id == exploit_id))
    exploit = result.scalar_one_or_none()
    
    if not exploit:
        raise HTTPException(status_code=404, detail="Exploit not found")
    
    # Add to RDF graph
    sparql = get_sparql_service()
    sparql.add_exploit(exploit)
    
    # Format response
    if format == "jsonld":
        jsonld = exploit_to_jsonld(exploit)
        await cache.set(cache_key, jsonld, ttl=300)
        return JSONResponse(content=jsonld, media_type="application/ld+json")
    
    if format == "html":
        html = exploit_to_rdfa_html(exploit, request)
        await cache.set(cache_key, html, ttl=300)
        return HTMLResponse(content=html)
    
    if format == "turtle":
        turtle = sparql.serialize(format="turtle")
        await cache.set(cache_key, turtle, ttl=300)
        return Response(content=turtle, media_type="text/turtle")
    
    if format == "rdf":
        rdf_xml = sparql.serialize(format="xml")
        await cache.set(cache_key, rdf_xml, ttl=300)
        return Response(content=rdf_xml, media_type="application/rdf+xml")
    
    # Default JSON
    response = ExploitResponse.model_validate(exploit)
    await cache.set(cache_key, response, ttl=300)
    return response


@router.get("/by-cve/{cve_id}")
async def get_exploit_by_cve(
    cve_id: str,
    format: str = Query("json", regex="^(json|jsonld)$"),
    db: AsyncSession = Depends(get_db),
):
    """Get exploit by CVE ID."""
    result = await db.execute(
        select(Exploit).where(Exploit.cve_id == cve_id)
    )
    exploit = result.scalar_one_or_none()
    
    if not exploit:
        raise HTTPException(status_code=404, detail=f"No exploit found for {cve_id}")
    
    if format == "jsonld":
        return JSONResponse(
            content=exploit_to_jsonld(exploit),
            media_type="application/ld+json"
        )
    
    return ExploitResponse.model_validate(exploit)


@router.get("/category/{category}")
async def get_exploits_by_category(
    category: str,
    page: int = Query(1, ge=1),
    page_size: int = Query(20, ge=1, le=100),
    db: AsyncSession = Depends(get_db),
):
    """Get exploits for a specific software category."""
    valid_categories = [e.value for e in SoftwareType]
    
    if category not in valid_categories:
        raise HTTPException(
            status_code=400,
            detail=f"Invalid category. Valid categories: {valid_categories}"
        )
    
    query = select(Exploit).where(Exploit.software_type == category)
    count_query = select(func.count(Exploit.id)).where(Exploit.software_type == category)
    
    total_result = await db.execute(count_query)
    total = total_result.scalar() or 0
    
    offset = (page - 1) * page_size
    query = query.order_by(Exploit.created_at.desc()).offset(offset).limit(page_size)
    
    result = await db.execute(query)
    exploits = result.scalars().all()
    
    return ExploitListResponse(
        items=[ExploitResponse.model_validate(e) for e in exploits],
        total=total,
        page=page,
        page_size=page_size,
        has_next=offset + len(exploits) < total,
    )

@router.post("/load-exploitdb")
async def load_exploitdb():
    """Trigger loading exploits from ExploitDB Git repository."""
    asyncio.create_task(force_load_exploits())
    return {"detail": "ExploitDB loading started."}

def generate_exploits_list_html(
    exploits: List[Exploit],
    page: int,
    page_size: int,
    total: int,
    request: Request,
) -> str:
    """Generate HTML page with RDFa for exploit list."""
    base_url = str(request.base_url).rstrip("/")
    
    items_html = ""
    for exploit in exploits:
        items_html += f'''
        <article typeof="schema:SoftwareApplication asc:WebExploit" 
                 resource="{base_url}/api/exploits/{exploit.id}"
                 class="exploit-card">
            <h3 property="schema:name">{exploit.title}</h3>
            <div class="exploit-meta">
                <span class="severity severity-{exploit.severity or 'unknown'}" 
                      property="asc:severity">{exploit.severity or 'Unknown'}</span>
                <span class="platform" property="asc:platform">{exploit.platform or 'Unknown'}</span>
                <span class="type" property="asc:exploitType">{exploit.exploit_type or 'Unknown'}</span>
            </div>
            <p property="schema:description">{(exploit.description or '')[:200]}...</p>
            <div class="exploit-footer">
                <span property="asc:affectedSoftware">{exploit.software_name or ''}</span>
                <a href="{base_url}/api/exploits/{exploit.id}?format=html">View Details</a>
                <a href="{base_url}/api/exploits/{exploit.id}?format=jsonld">JSON-LD</a>
            </div>
        </article>
        '''
    
    return f'''<!DOCTYPE html>
<html lang="en" prefix="schema: https://schema.org/ asc: {settings.asc_namespace}">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Security Exploits - ASC</title>
    <link rel="alternate" type="application/ld+json" href="{base_url}/api/exploits?format=jsonld">
    <style>
        :root {{
            --bg: #0a0a0f;
            --surface: #12121a;
            --border: #1e1e2e;
            --text: #e4e4e7;
            --muted: #71717a;
            --accent: #f43f5e;
            --critical: #ef4444;
            --high: #f97316;
            --medium: #eab308;
            --low: #22c55e;
        }}
        * {{ box-sizing: border-box; margin: 0; padding: 0; }}
        body {{
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
        }}
        .container {{ max-width: 1200px; margin: 0 auto; padding: 2rem; }}
        h1 {{ 
            font-size: 2rem; 
            margin-bottom: 0.5rem;
            background: linear-gradient(135deg, var(--accent), #a855f7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }}
        .subtitle {{ color: var(--muted); margin-bottom: 2rem; }}
        .exploits-grid {{ display: grid; gap: 1rem; }}
        .exploit-card {{
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1.5rem;
            transition: border-color 0.2s;
        }}
        .exploit-card:hover {{ border-color: var(--accent); }}
        .exploit-card h3 {{ font-size: 1.1rem; margin-bottom: 0.75rem; }}
        .exploit-meta {{ display: flex; gap: 0.75rem; margin-bottom: 1rem; flex-wrap: wrap; }}
        .exploit-meta span {{
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            background: var(--border);
        }}
        .severity-critical {{ background: var(--critical) !important; color: white; }}
        .severity-high {{ background: var(--high) !important; color: black; }}
        .severity-medium {{ background: var(--medium) !important; color: black; }}
        .severity-low {{ background: var(--low) !important; color: black; }}
        .exploit-card p {{ color: var(--muted); font-size: 0.9rem; margin-bottom: 1rem; }}
        .exploit-footer {{
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: 1rem;
            border-top: 1px solid var(--border);
            font-size: 0.85rem;
        }}
        .exploit-footer a {{
            color: var(--accent);
            text-decoration: none;
        }}
        .pagination {{
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 2rem;
        }}
        .pagination a {{
            color: var(--accent);
            text-decoration: none;
            padding: 0.5rem 1rem;
            border: 1px solid var(--border);
            border-radius: 4px;
        }}
    </style>
</head>
<body vocab="https://schema.org/">
    <div class="container">
        <header>
            <h1>üõ°Ô∏è Security Exploits Database</h1>
            <p class="subtitle">Page {page} of {(total + page_size - 1) // page_size} ‚Ä¢ {total} total exploits</p>
        </header>
        <main class="exploits-grid">
            {items_html}
        </main>
        <nav class="pagination">
            {"<a href='?format=html&page=" + str(page-1) + "'>‚Üê Previous</a>" if page > 1 else ""}
            {"<a href='?format=html&page=" + str(page+1) + "'>Next ‚Üí</a>" if page * page_size < total else ""}
        </nav>
    </div>
</body>
</html>'''
