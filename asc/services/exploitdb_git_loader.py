"""
Service for cloning and loading exploits from exploit-database git repository.
"""

import asyncio
import logging
import os
import re
from datetime import datetime
from pathlib import Path
import shutil
from typing import Dict, List, Optional, AsyncGenerator
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from .sparql_service import get_sparql_service
from .pubsub import publish_exploit_alert
from .websub import publish_exploit_alert as publish_exploit_alert_webhub
from ..models.database import async_session_maker
from ..models.exploit import Exploit, ExploitCreate
from ..config import get_settings

logger = logging.getLogger(__name__)
settings = get_settings()


class ExploitDBGitLoader:
    """
    Service for cloning exploit-database repository and loading exploits
    from the webapps directories.
    """
    
    REPO_URL = "https://gitlab.com/exploit-database/exploitdb.git"
    
    def __init__(self, clone_dir: Optional[str] = None):
        """
        Initialize the loader.
        
        Args:
            clone_dir: Directory to clone the repo into. Defaults to './data/exploitdb'
        """
        if clone_dir is None:
            clone_dir = os.path.join(os.getcwd(), "data", "exploitdb")
        
        self.clone_dir = Path(clone_dir)
        self.exploit_dir = self.clone_dir / "exploits"
        
    async def clone_or_update_repo(self) -> bool:
        """
        Clone the exploit-database repository or update if it already exists.
        
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            # Create parent directory if it doesn't exist
            self.clone_dir.parent.mkdir(parents=True, exist_ok=True)
            
            if self.clone_dir.exists():
                shutil.rmtree(self.clone_dir)

            logger.info(f"Cloning repository to {self.clone_dir}...")
            # Clone the repository
            process = await asyncio.create_subprocess_exec(
                "git", "clone", "--depth", "1", self.REPO_URL, str(self.clone_dir),
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout, stderr = await process.communicate()
            
            if process.returncode == 0:
                logger.info("Repository cloned successfully")
                return True
            else:
                logger.error(f"Failed to clone repository: {stderr.decode()}")
                return False
                    
        except Exception as e:
            logger.error(f"Error cloning/updating repository: {str(e)}")
            return False
    
    def parse_exploit_file(self, file_path: Path) -> Optional[Dict]:
        """
        Parse an exploit file and extract metadata.
        
        Args:
            file_path: Path to the exploit file
            
        Returns:
            Dict with exploit metadata or None if parsing fails
        """
        try:
            # Only process text files (typically .txt, .py, .php, .rb, .pl, etc.)
            if not file_path.is_file():
                return None
                
            # Read file content
            try:
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
            except Exception as e:
                logger.debug(f"Could not read file {file_path}: {e}")
                return None
            
            # Extract exploit DB ID from filename (e.g., 12345.txt -> 12345)
            exploit_db_id = file_path.stem
            
            # Parse metadata from file header
            metadata = self._parse_metadata(content)
            
            # Extract exploit code (everything after metadata header)
            exploit_code = self._extract_code(content)
            
            # Determine platform from file extension or content
            platform = self._detect_platform(file_path, content)
            
            # Detect exploit type from title and content
            exploit_type = self._detect_exploit_type(
                metadata.get('title', ''),
                content
            )
            
            # Detect software type
            software_type = self._detect_software_type(
                metadata.get('title', ''),
                content
            )
            
            return {
                'exploit_db_id': exploit_db_id,
                'title': metadata.get('title', file_path.name),
                'description': metadata.get('description'),
                'platform': platform,
                'software_type': software_type,
                'exploit_type': exploit_type,
                'software_name': metadata.get('software'),
                'software_version': metadata.get('version'),
                'vendor': metadata.get('vendor'),
                'author': metadata.get('author'),
                'published_date': metadata.get('date'),
                'cve_id': metadata.get('cve'),
                'exploit_code': exploit_code,
                'source_url': f"https://www.exploit-db.com/exploits/{exploit_db_id}",
                'references': self._extract_references(content),
            }
            
        except Exception as e:
            logger.error(f"Error parsing file {file_path}: {str(e)}")
            return None
    
    def _parse_metadata(self, content: str) -> Dict:
        """
        Parse metadata from exploit file header.
        
        The header typically contains fields like:
        # Exploit Title: ...
        # Date: ...
        # Author: ...
        # Vendor Homepage: ...
        # Software Link: ...
        # Version: ...
        # CVE: ...
        """
        metadata = {}
        
        # Common metadata fields
        patterns = {
            'title': r'#\s*Exploit\s+Title\s*:\s*(.+)',
            'date': r'#\s*Date\s*:\s*(.+)',
            'author': r'#\s*Author\s*:\s*(.+)',
            'vendor': r'#\s*Vendor\s+Homepage\s*:\s*(.+)',
            'software': r'#\s*Software\s+(?:Link|Name)\s*:\s*(.+)',
            'version': r'#\s*Version\s*:\s*(.+)',
            'cve': r'#\s*CVE\s*:\s*(.+)',
            'description': r'#\s*Description\s*:\s*(.+)',
        }
        
        for key, pattern in patterns.items():
            match = re.search(pattern, content, re.IGNORECASE | re.MULTILINE)
            if match:
                value = match.group(1).strip()
                if key == 'date':
                    # Try to parse date
                    try:
                        metadata[key] = datetime.strptime(value, '%Y-%m-%d')
                    except:
                        try:
                            metadata[key] = datetime.strptime(value, '%m/%d/%Y')
                        except:
                            pass
                else:
                    metadata[key] = value
        
        return metadata
    
    def _extract_code(self, content: str) -> str:
        """
        Extract the actual exploit code from the file content.
        Usually everything after the header comments.
        """
        # Find the end of the header (last line starting with #)
        lines = content.split('\n')
        code_start_idx = 0
        
        for i, line in enumerate(lines):
            stripped = line.strip()
            if stripped and not stripped.startswith('#'):
                code_start_idx = i
                break
        
        return '\n'.join(lines[code_start_idx:])
    
    def _detect_platform(self, file_path: Path, content: str) -> str:
        """Detect the platform/language from file extension or content."""
        ext = file_path.suffix.lower()
        
        platform_map = {
            '.php': 'php',
            '.py': 'python',
            '.rb': 'ruby',
            '.pl': 'perl',
            '.asp': 'asp',
            '.aspx': 'aspx',
            '.jsp': 'jsp',
            '.js': 'nodejs',
        }
        
        if ext in platform_map:
            return platform_map[ext]
        
        # Try to detect from content
        content_lower = content.lower()
        if 'php' in content_lower or '<?php' in content:
            return 'php'
        elif 'python' in content_lower or 'import ' in content:
            return 'python'
        elif 'ruby' in content_lower or 'require ' in content:
            return 'ruby'
        
        return 'other'
    
    def _detect_exploit_type(self, title: str, content: str) -> str:
        """Detect exploit type from title and content."""
        combined = (title + ' ' + content[:500]).lower()
        
        patterns = {
            'sqli': r'sql\s*inject',
            'xss': r'cross.site.script|xss',
            'rce': r'remote\s*code\s*exec|rce',
            'lfi': r'local\s*file\s*inclu|lfi',
            'rfi': r'remote\s*file\s*inclu|rfi',
            'csrf': r'cross.site.request|csrf',
            'auth_bypass': r'auth.*bypass',
            'file_upload': r'file\s*upload',
            'ssrf': r'server.side.request|ssrf',
            'xxe': r'xml.*external|xxe',
        }
        
        for exploit_type, pattern in patterns.items():
            if re.search(pattern, combined):
                return exploit_type
        
        return 'other'
    
    def _detect_software_type(self, title: str, content: str) -> str:
        """Detect software type from title and content."""
        combined = (title + ' ' + content[:500]).lower()
        
        type_keywords = {
            'cms': ['wordpress', 'drupal', 'joomla', 'cms'],
            'framework': ['laravel', 'django', 'rails', 'framework'],
            'plugin': ['plugin', 'addon', 'extension', 'module'],
            'shopping_cart': ['cart', 'woocommerce', 'opencart', 'prestashop'],
            'forum': ['forum', 'phpbb', 'vbulletin'],
        }
        
        for sw_type, keywords in type_keywords.items():
            if any(keyword in combined for keyword in keywords):
                return sw_type
        
        return 'other'
    
    def _extract_references(self, content: str) -> str:
        """Extract reference URLs from content."""
        # Find URLs in the content
        url_pattern = r'https?://[^\s<>"\')]+[^\s<>"\').,;]'
        urls = re.findall(url_pattern, content)
        
        if urls:
            # Return as JSON-like string
            import json
            return json.dumps(urls[:10])  # Limit to first 10 URLs
        
        return None
    
    async def load_webapps_exploits(self, limit: Optional[int] = None) -> AsyncGenerator[Dict, None]:
        """
        Load exploits from the webapps directory.
        
        Args:
            limit: Maximum number of exploits to load (None for all)
            
        Yields:
            Dict: Parsed exploit data
        """
        if not self.exploit_dir.exists():
            logger.error(f"Exploits directory does not exist: {self.exploit_dir}")
            return
        
        logger.info(f"Loading exploits from {self.exploit_dir}")
        
        # Get all files in webapps directory
        files = list(self.exploit_dir.glob('**/webapps/*'))
        logger.info(f"Found {len(files)} files in webapps directory")
        
        count = 0
        for file_path in files:
            if limit and count >= limit:
                break
                
            exploit_data = self.parse_exploit_file(file_path)
            if exploit_data:
                yield exploit_data
                count += 1
                
                if count % 100 == 0:
                    logger.info(f"Processed {count} exploits...")
    
    async def save_exploits_to_db(self, limit: Optional[int] = None) -> int:
        """
        Load exploits from repository and save to database.
        
        Args:
            limit: Maximum number of exploits to save (None for all)
            
        Returns:
            int: Number of exploits saved
        """
        count = 0

        sparql = get_sparql_service()
        
        async with async_session_maker() as session:
            async for exploit_data in self.load_webapps_exploits(limit=limit):
                try:
                    # Check if exploit already exists
                    exploit_db_id = exploit_data.get('exploit_db_id')
                    if exploit_db_id:
                        result = await session.execute(
                            select(Exploit).where(Exploit.exploit_db_id == exploit_db_id)
                        )
                        existing = result.scalar_one_or_none()
                        
                        if existing:
                            logger.debug(f"Exploit {exploit_db_id} already exists, skipping")
                            continue
                    
                    # Create new exploit
                    exploit = Exploit(**exploit_data)
                    session.add(exploit)
                    sparql.add_exploit(exploit)
                    await publish_exploit_alert(exploit_data)
                    await publish_exploit_alert_webhub(exploit_data)
                    count += 1
                    
                    # Commit in batches
                    if count % 50 == 0:
                        await session.commit()
                        logger.info(f"Saved {count} exploits to database")
                        
                except Exception as e:
                    logger.error(f"Error saving exploit: {str(e)}")
                    await session.rollback()
            
            # Final commit
            await session.commit()
        
        logger.info(f"Total exploits saved: {count}")
        return count
    
    async def run(self, limit: Optional[int] = None) -> int:
        """
        Main method to clone repo and load exploits.
        
        Args:
            limit: Maximum number of exploits to load (None for all)
            
        Returns:
            int: Number of exploits loaded
        """
        logger.info("Starting ExploitDB Git Loader")
        
        # Clone or update repository
        success = await self.clone_or_update_repo()
        if not success:
            logger.error("Failed to clone/update repository")
            return 0
        
        # Load and save exploits
        count = await self.save_exploits_to_db(limit=limit)
        
        logger.info(f"ExploitDB Git Loader completed. Loaded {count} exploits.")
        return count

async def start_loading_exploits():
    """
    Start the exploit loading process as a background task.
    Runs periodically every 10 minutes.
    """
    await asyncio.sleep(600)  # 10 minutes
    while True:
        try:
            logger.info("Starting periodic exploit loading...")
            loader = ExploitDBGitLoader()
            await loader.run(limit=1000)
            logger.info("Waiting 10 minutes before next run...")
            await asyncio.sleep(600)
        except Exception as e:
            logger.error(f"Error in periodic exploit loading: {str(e)}")
            logger.info("Retrying in 10 minutes...")
            await asyncio.sleep(600)


SAMPLE_EXPLOITS = [
    {
        "exploit_db_id": "SAMPLE-001",
        "title": "WordPress Plugin ContactForm 2.5.0 - SQL Injection",
        "description": "The ContactForm plugin for WordPress versions prior to 2.5.1 is vulnerable to SQL injection via the 'id' parameter.",
        "platform": "php",
        "software_type": "plugin",
        "exploit_type": "sqli",
        "severity": "critical",
        "software_name": "ContactForm Plugin",
        "software_version": "2.5.0",
        "vendor": "WordPress",
        "cve_id": "CVE-2024-XXXXX",
        "solution": "Update to version 2.5.1 or later. Implement parameterized queries.",
        "mitigation": "Use a Web Application Firewall (WAF) to filter malicious SQL queries. Validate and sanitize all user inputs.",
    },
    {
        "exploit_db_id": "SAMPLE-002",
        "title": "Drupal Core 9.x - Remote Code Execution",
        "description": "A vulnerability in Drupal Core allows authenticated users to execute arbitrary PHP code.",
        "platform": "php",
        "software_type": "cms",
        "exploit_type": "rce",
        "severity": "critical",
        "software_name": "Drupal",
        "software_version": "9.4.0",
        "vendor": "Drupal Association",
        "cve_id": "CVE-2024-YYYYY",
        "solution": "Apply the security patch from Drupal.org immediately.",
        "mitigation": "Restrict file upload permissions. Monitor system for unauthorized code execution.",
    },
    {
        "exploit_db_id": "SAMPLE-003",
        "title": "OpenCart 4.0.1 - Cross-Site Scripting (XSS)",
        "description": "OpenCart e-commerce platform contains a stored XSS vulnerability in the product review section.",
        "platform": "php",
        "software_type": "shopping_cart",
        "exploit_type": "xss",
        "severity": "medium",
        "software_name": "OpenCart",
        "software_version": "4.0.1",
        "vendor": "OpenCart Ltd",
        "solution": "Upgrade to OpenCart 4.0.2 which includes proper output encoding.",
        "mitigation": "Implement Content Security Policy (CSP). Sanitize user inputs before display.",
    },
    {
        "exploit_db_id": "SAMPLE-004",
        "title": "Laravel Debug Mode - Information Disclosure",
        "description": "When Laravel debug mode is enabled in production, sensitive information including database credentials may be exposed.",
        "platform": "php",
        "software_type": "framework",
        "exploit_type": "other",
        "severity": "high",
        "software_name": "Laravel",
        "software_version": "10.x",
        "vendor": "Laravel LLC",
        "solution": "Ensure APP_DEBUG=false in production .env file.",
        "mitigation": "Use environment-specific configuration. Never expose debug information in production.",
    },
    {
        "exploit_db_id": "SAMPLE-005",
        "title": "phpBB 3.3.x - CSRF Token Bypass",
        "description": "phpBB forum software contains a CSRF vulnerability allowing attackers to perform actions on behalf of authenticated users.",
        "platform": "php",
        "software_type": "forum",
        "exploit_type": "csrf",
        "severity": "medium",
        "software_name": "phpBB",
        "software_version": "3.3.8",
        "vendor": "phpBB Group",
        "cve_id": "CVE-2024-ZZZZZ",
        "solution": "Update to the latest phpBB version with the security fix.",
        "mitigation": "Implement SameSite cookie attribute. Use anti-CSRF tokens on all forms.",
    },
]

async def force_load_exploits():
    loader = ExploitDBGitLoader()
    await loader.run(limit=1000)


async def load_sample_exploits(db: AsyncSession) -> List[Exploit]:
    """Load sample exploits for demonstration."""
    exploits = []
    
    for data in SAMPLE_EXPLOITS:
        existing = await db.execute(
            select(Exploit).where(Exploit.exploit_db_id == data["exploit_db_id"])
        )
        result = existing.scalar_one_or_none()
        if not result:
            exploit = Exploit(**data, published_date=datetime.now())
            db.add(exploit)
        else:
            exploit = result
        exploits.append(exploit)
    
    await db.commit()
    return exploits

