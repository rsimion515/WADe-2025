"""
Exploit-DB scraper service for fetching web application vulnerabilities.
"""

import asyncio
import httpx
import logging
import re
from bs4 import BeautifulSoup
from datetime import datetime
from typing import List, Dict, Optional, AsyncGenerator
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from ..models.exploit import Exploit, ExploitCreate
from ..config import get_settings

logger = logging.getLogger(__name__)
settings = get_settings()


class ExploitScraper:
    """
    Scraper for fetching exploits from Exploit-DB.
    Focuses on web application vulnerabilities (webapps type).
    """
    
    BASE_URL = "https://www.exploit-db.com"
    WEBAPPS_URL = f"{BASE_URL}/?type=webapps"
    
    # Mapping of platform keywords to normalized platform types
    PLATFORM_MAP = {
        "php": "php",
        "asp": "asp",
        "aspx": "aspx",
        "jsp": "jsp",
        "java": "java",
        "python": "python",
        "ruby": "ruby",
        "nodejs": "nodejs",
        "node.js": "nodejs",
        "javascript": "nodejs",
        "multiple": "multiple",
    }
    
    # Software type detection keywords
    SOFTWARE_TYPE_KEYWORDS = {
        "cms": ["wordpress", "drupal", "joomla", "typo3", "concrete5", "cms"],
        "framework": ["laravel", "django", "rails", "spring", "express", "framework"],
        "plugin": ["plugin", "addon", "extension", "module"],
        "shopping_cart": ["cart", "woocommerce", "opencart", "prestashop", "magento", "shop"],
        "forum": ["forum", "phpbb", "vbulletin", "mybb", "discourse"],
        "wiki": ["wiki", "mediawiki", "dokuwiki"],
        "blog": ["blog", "wordpress", "ghost"],
        "e_commerce": ["ecommerce", "e-commerce", "magento", "shopify"],
    }
    
    # Exploit type detection patterns
    EXPLOIT_TYPE_PATTERNS = {
        "sqli": [r"sql\s*inject", r"sqli", r"sql\s*vuln"],
        "xss": [r"cross.site.script", r"xss", r"reflected", r"stored\s*xss"],
        "rce": [r"remote\s*code\s*exec", r"rce", r"command\s*exec"],
        "lfi": [r"local\s*file\s*inclu", r"lfi", r"path\s*travers"],
        "rfi": [r"remote\s*file\s*inclu", r"rfi"],
        "csrf": [r"cross.site.request", r"csrf", r"xsrf"],
        "auth_bypass": [r"auth.*bypass", r"authentication\s*bypass", r"login\s*bypass"],
        "file_upload": [r"file\s*upload", r"arbitrary\s*upload", r"shell\s*upload"],
        "ssrf": [r"server.side.request", r"ssrf"],
        "xxe": [r"xml.*external", r"xxe", r"xml\s*inject"],
        "deserialization": [r"deseriali", r"unseriali", r"object\s*inject"],
    }
    
    def __init__(self):
        """Initialize the scraper."""
        self.client: Optional[httpx.AsyncClient] = None
    
    async def __aenter__(self):
        """Async context manager entry."""
        self.client = httpx.AsyncClient(
            timeout=30.0,
            follow_redirects=True,
            headers={
                "User-Agent": "ASC Security Monitor/1.0 (Educational Research)",
                "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
            }
        )
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit."""
        if self.client:
            await self.client.aclose()
    
    async def fetch_exploit_list(self, page: int = 1) -> List[Dict]:
        """
        Fetch list of exploits from Exploit-DB webapps page.
        
        Args:
            page: Page number to fetch
            
        Returns:
            List of exploit metadata dictionaries
        """
        exploits = []
        
        try:
            url = f"{self.WEBAPPS_URL}&page={page}"
            response = await self.client.get(url)
            response.raise_for_status()
            
            soup = BeautifulSoup(response.text, "lxml")
            
            # Find the exploit table
            table = soup.find("table", {"id": "exploits-table"})
            if not table:
                # Try alternative selectors
                table = soup.find("table", class_="table")
            
            if table:
                rows = table.find_all("tr")[1:]  # Skip header
                
                for row in rows:
                    exploit_data = self._parse_table_row(row)
                    if exploit_data:
                        exploits.append(exploit_data)
            
            logger.info(f"Fetched {len(exploits)} exploits from page {page}")
            
        except httpx.HTTPError as e:
            logger.error(f"HTTP error fetching exploit list: {e}")
        except Exception as e:
            logger.error(f"Error parsing exploit list: {e}")
        
        return exploits
    
    def _parse_table_row(self, row) -> Optional[Dict]:
        """Parse a table row into exploit metadata."""
        try:
            cells = row.find_all("td")
            if len(cells) < 5:
                return None
            
            # Extract date
            date_cell = cells[0].get_text(strip=True)
            
            # Extract title and link
            title_cell = cells[4] if len(cells) > 4 else cells[3]
            title_link = title_cell.find("a")
            
            if not title_link:
                return None
            
            title = title_link.get_text(strip=True)
            href = title_link.get("href", "")
            
            # Extract exploit ID from URL
            exploit_id = None
            if "/exploits/" in href:
                match = re.search(r"/exploits/(\d+)", href)
                if match:
                    exploit_id = match.group(1)
            
            # Extract platform
            platform_cell = cells[5] if len(cells) > 5 else None
            platform = platform_cell.get_text(strip=True) if platform_cell else "unknown"
            
            # Extract author
            author_cell = cells[7] if len(cells) > 7 else None
            author = author_cell.get_text(strip=True) if author_cell else "Unknown"
            
            return {
                "exploit_db_id": exploit_id,
                "title": title,
                "source_url": f"{self.BASE_URL}{href}" if href.startswith("/") else href,
                "platform": self._normalize_platform(platform),
                "author": author,
                "published_date": self._parse_date(date_cell),
            }
            
        except Exception as e:
            logger.debug(f"Error parsing row: {e}")
            return None
    
    async def fetch_exploit_details(self, exploit_id: str) -> Optional[Dict]:
        """
        Fetch detailed information for a specific exploit.
        
        Args:
            exploit_id: Exploit-DB ID
            
        Returns:
            Detailed exploit information
        """
        try:
            url = f"{self.BASE_URL}/exploits/{exploit_id}"
            response = await self.client.get(url)
            response.raise_for_status()
            
            soup = BeautifulSoup(response.text, "lxml")
            
            # Extract title
            title_elem = soup.find("h1")
            title = title_elem.get_text(strip=True) if title_elem else ""
            
            # Extract description
            desc_elem = soup.find("div", class_="description")
            description = desc_elem.get_text(strip=True) if desc_elem else ""
            
            # Extract CVE
            cve_match = re.search(r"CVE-\d{4}-\d+", response.text)
            cve_id = cve_match.group(0) if cve_match else None
            
            # Extract exploit code
            code_elem = soup.find("pre", class_="exploit-code") or soup.find("code")
            exploit_code = code_elem.get_text() if code_elem else None
            
            # Detect software type and exploit type
            full_text = f"{title} {description}".lower()
            software_type = self._detect_software_type(full_text)
            exploit_type = self._detect_exploit_type(full_text)
            
            # Extract software name from title
            software_name = self._extract_software_name(title)
            
            # Determine severity based on exploit type
            severity = self._determine_severity(exploit_type)
            
            return {
                "exploit_db_id": exploit_id,
                "title": title,
                "description": description,
                "cve_id": cve_id,
                "exploit_code": exploit_code,
                "software_type": software_type,
                "exploit_type": exploit_type,
                "software_name": software_name,
                "severity": severity,
                "source_url": url,
            }
            
        except httpx.HTTPError as e:
            logger.error(f"HTTP error fetching exploit {exploit_id}: {e}")
        except Exception as e:
            logger.error(f"Error fetching exploit {exploit_id}: {e}")
        
        return None
    
    def _normalize_platform(self, platform: str) -> str:
        """Normalize platform string to standard type."""
        platform_lower = platform.lower()
        for key, value in self.PLATFORM_MAP.items():
            if key in platform_lower:
                return value
        return "other"
    
    def _detect_software_type(self, text: str) -> str:
        """Detect software type from text."""
        for sw_type, keywords in self.SOFTWARE_TYPE_KEYWORDS.items():
            for keyword in keywords:
                if keyword in text:
                    return sw_type
        return "other"
    
    def _detect_exploit_type(self, text: str) -> str:
        """Detect exploit type from text."""
        for exp_type, patterns in self.EXPLOIT_TYPE_PATTERNS.items():
            for pattern in patterns:
                if re.search(pattern, text, re.IGNORECASE):
                    return exp_type
        return "other"
    
    def _extract_software_name(self, title: str) -> str:
        """Extract software name from exploit title."""
        # Common patterns: "SoftwareName 1.0 - Vulnerability Type"
        match = re.match(r"^([^0-9<>]+?)[\s\d.]+[-â€“]", title)
        if match:
            return match.group(1).strip()
        
        # Try extracting first meaningful words
        words = title.split()
        if words:
            return " ".join(words[:2])
        
        return "Unknown"
    
    def _determine_severity(self, exploit_type: str) -> str:
        """Determine severity based on exploit type."""
        critical_types = {"rce", "sqli", "auth_bypass", "deserialization"}
        high_types = {"file_upload", "xxe", "ssrf", "lfi", "rfi"}
        medium_types = {"xss", "csrf"}
        
        if exploit_type in critical_types:
            return "critical"
        elif exploit_type in high_types:
            return "high"
        elif exploit_type in medium_types:
            return "medium"
        return "low"
    
    def _parse_date(self, date_str: str) -> Optional[datetime]:
        """Parse date string to datetime."""
        try:
            # Try common date formats
            for fmt in ["%Y-%m-%d", "%d-%m-%Y", "%m/%d/%Y", "%Y/%m/%d"]:
                try:
                    return datetime.strptime(date_str, fmt)
                except ValueError:
                    continue
        except Exception:
            pass
        return None
    
    async def scrape_new_exploits(
        self,
        db: AsyncSession,
        max_pages: int = 3,
    ) -> List[Exploit]:
        """
        Scrape new exploits and store them in database.
        
        Args:
            db: Database session
            max_pages: Maximum number of pages to scrape
            
        Returns:
            List of newly created exploit records
        """
        new_exploits = []
        
        for page in range(1, max_pages + 1):
            exploit_list = await self.fetch_exploit_list(page)
            
            for exploit_data in exploit_list:
                exploit_id = exploit_data.get("exploit_db_id")
                if not exploit_id:
                    continue
                
                # Check if exploit already exists
                existing = await db.execute(
                    select(Exploit).where(Exploit.exploit_db_id == exploit_id)
                )
                if existing.scalar_one_or_none():
                    continue
                
                # Fetch detailed information
                details = await self.fetch_exploit_details(exploit_id)
                if details:
                    exploit_data.update(details)
                
                # Create exploit record
                exploit = Exploit(**exploit_data)
                db.add(exploit)
                new_exploits.append(exploit)
                
                # Rate limiting
                await asyncio.sleep(0.5)
            
            await asyncio.sleep(1)  # Delay between pages
        
        await db.commit()
        logger.info(f"Created {len(new_exploits)} new exploit records")
        
        return new_exploits


# Sample exploits for demonstration when scraping is not available
SAMPLE_EXPLOITS = [
    {
        "exploit_db_id": "SAMPLE-001",
        "title": "WordPress Plugin ContactForm 2.5.0 - SQL Injection",
        "description": "The ContactForm plugin for WordPress versions prior to 2.5.1 is vulnerable to SQL injection via the 'id' parameter.",
        "platform": "php",
        "software_type": "plugin",
        "exploit_type": "sqli",
        "severity": "critical",
        "software_name": "ContactForm Plugin",
        "software_version": "2.5.0",
        "vendor": "WordPress",
        "cve_id": "CVE-2024-XXXXX",
        "solution": "Update to version 2.5.1 or later. Implement parameterized queries.",
        "mitigation": "Use a Web Application Firewall (WAF) to filter malicious SQL queries. Validate and sanitize all user inputs.",
    },
    {
        "exploit_db_id": "SAMPLE-002",
        "title": "Drupal Core 9.x - Remote Code Execution",
        "description": "A vulnerability in Drupal Core allows authenticated users to execute arbitrary PHP code.",
        "platform": "php",
        "software_type": "cms",
        "exploit_type": "rce",
        "severity": "critical",
        "software_name": "Drupal",
        "software_version": "9.4.0",
        "vendor": "Drupal Association",
        "cve_id": "CVE-2024-YYYYY",
        "solution": "Apply the security patch from Drupal.org immediately.",
        "mitigation": "Restrict file upload permissions. Monitor system for unauthorized code execution.",
    },
    {
        "exploit_db_id": "SAMPLE-003",
        "title": "OpenCart 4.0.1 - Cross-Site Scripting (XSS)",
        "description": "OpenCart e-commerce platform contains a stored XSS vulnerability in the product review section.",
        "platform": "php",
        "software_type": "shopping_cart",
        "exploit_type": "xss",
        "severity": "medium",
        "software_name": "OpenCart",
        "software_version": "4.0.1",
        "vendor": "OpenCart Ltd",
        "solution": "Upgrade to OpenCart 4.0.2 which includes proper output encoding.",
        "mitigation": "Implement Content Security Policy (CSP). Sanitize user inputs before display.",
    },
    {
        "exploit_db_id": "SAMPLE-004",
        "title": "Laravel Debug Mode - Information Disclosure",
        "description": "When Laravel debug mode is enabled in production, sensitive information including database credentials may be exposed.",
        "platform": "php",
        "software_type": "framework",
        "exploit_type": "other",
        "severity": "high",
        "software_name": "Laravel",
        "software_version": "10.x",
        "vendor": "Laravel LLC",
        "solution": "Ensure APP_DEBUG=false in production .env file.",
        "mitigation": "Use environment-specific configuration. Never expose debug information in production.",
    },
    {
        "exploit_db_id": "SAMPLE-005",
        "title": "phpBB 3.3.x - CSRF Token Bypass",
        "description": "phpBB forum software contains a CSRF vulnerability allowing attackers to perform actions on behalf of authenticated users.",
        "platform": "php",
        "software_type": "forum",
        "exploit_type": "csrf",
        "severity": "medium",
        "software_name": "phpBB",
        "software_version": "3.3.8",
        "vendor": "phpBB Group",
        "cve_id": "CVE-2024-ZZZZZ",
        "solution": "Update to the latest phpBB version with the security fix.",
        "mitigation": "Implement SameSite cookie attribute. Use anti-CSRF tokens on all forms.",
    },
]


async def load_sample_exploits(db: AsyncSession) -> List[Exploit]:
    """Load sample exploits for demonstration."""
    exploits = []
    
    for data in SAMPLE_EXPLOITS:
        existing = await db.execute(
            select(Exploit).where(Exploit.exploit_db_id == data["exploit_db_id"])
        )
        result = existing.scalar_one_or_none()
        if not result:
            exploit = Exploit(**data, published_date=datetime.now())
            db.add(exploit)
        else:
            exploit = result
        exploits.append(exploit)
    
    await db.commit()
    return exploits
